import os
import subprocess
import sys

class CustomShell:
    def __init__(self):
        self.commands = {
            'help': self.help_command,
            'exit': self.exit_command,
            'modify': self.modify_permissions,
            'list': self.list_attributes
        }

    def parse_command(self, command):
        if '|' in command:
            return 'pipe', command.split('|')
        elif '>' in command:
            return 'redirect_output', command.split('>')
        elif '<' in command:
            return 'redirect_input', command.split('<')
        else:
            return 'simple', command.split()

    def execute_command(self, command):
        cmd_type, parts = self.parse_command(command)

        if cmd_type == 'simple':
            cmd = parts[0]
            if cmd in self.commands:
                self.commands[cmd](parts[1:])
            else:
                self.run_external_command(parts)
        elif cmd_type == 'pipe':
            self.execute_piped_commands(parts)
        elif cmd_type == 'redirect_output':
            self.redirect_output(parts)
        elif cmd_type == 'redirect_input':
            self.redirect_input(parts)
        else:
            print("Invalid command")

    def run_external_command(self, command):
        try:
            subprocess.run(command)
        except Exception as e:
            print(f"Error running command: {e}")

    def help_command(self, args):
        if args:
            print("Usage: help")
        else:
            print("Available commands: help, exit, modify, list")

    def exit_command(self, args):
        if args:
            print("Usage: exit")
        else:
            print("Exiting...")
            sys.exit(0)

    def modify_permissions(self, args):
        if len(args) != 2:
            print("Usage: modify <file> <permissions>")
        else:
            try:
                # Ensure args[1] is a valid octal number
                permissions = int(args[1], 8)
                os.chmod(args[0], permissions)
                print(f"Permissions of {args[0]} changed to {args[1]}")
            except ValueError:
                print("Invalid permissions format. Use an octal number (e.g., 755).")
            except Exception as e:
                print(f"Error modifying permissions: {e}")

    def list_attributes(self, args):
        if len(args) != 1:
            print("Usage: list <directory>")
        else:
            try:
                for file in os.listdir(args[0]):
                    print(file)
            except Exception as e:
                print(f"Error listing directory: {e}")

    import subprocess

    def execute_piped_commands(self, commands):
        processes = []

        for command in commands:
            # Split command into parts
            parts = command.strip().split()

            if processes:
                # Chain the current command to the previous one using stdin from previous process
                processes.append(
                    subprocess.Popen(parts, stdin=processes[-1].stdout, stdout=subprocess.PIPE)
                )
                processes[-1].stdout.close()  # Allow the last command to complete
            else:
                # Start the first process
                processes.append(subprocess.Popen(parts, stdout=subprocess.PIPE))

        if processes:
            # Get the final output and error (if any)
            output, error = processes[-1].communicate()
            # Print the final output
            print(output.decode() if output else error.decode())

    # Example usage
    commands = [
        #'dir C:\\Users\\waltp\\OneDrive\\Documents',  # Or 'ls' for Unix-based systems
        #'findstr /C:"Tartar"'  # Or 'grep' for Unix-based systems
    ]
    execute_piped_commands(None, commands)

    def redirect_output(self, parts):
        command, outfile = parts[0].strip(), parts[1].strip()
        try:
            with open(outfile, 'w') as f:
                subprocess.run(command.split(), stdout=f)
        except Exception as e:
            print(f"Error redirecting output: {e}")

    def redirect_input(self, parts):
        command, infile = parts[0].strip(), parts[1].strip()
        try:
            with open(infile, 'r') as f:
                subprocess.run(command.split(), stdin=f)
        except Exception as e:
            print(f"Error redirecting input: {e}")


if __name__ == '__main__':
    cp = CustomShell()
    while True:
        command = input("Enter command: ")
        cp.execute_command(command)
